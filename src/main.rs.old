use std::{collections::HashMap, path::Path};

use druid::{
    widget::{Flex, WidgetExt},
    AppLauncher, Insets, Widget, WindowDesc,
};

use druid::widget::*;
use druid::Lens;
use druid::LensExt;
use fpi::{AppState, ToDruidImage};
use image::{DynamicImage, GenericImageView};

struct ImageController;

impl<T, W: Widget<T>> Controller<T, W> for ImageController {
    fn event(
        &mut self,
        child: &mut W,
        ctx: &mut druid::EventCtx,
        event: &druid::Event,
        data: &mut T,
        env: &druid::Env,
    ) {
        child.event(ctx, event, data, env)
    }

    fn lifecycle(
        &mut self,
        child: &mut W,
        ctx: &mut druid::LifeCycleCtx,
        event: &druid::LifeCycle,
        data: &T,
        env: &druid::Env,
    ) {
        child.lifecycle(ctx, event, data, env)
    }

    fn update(
        &mut self,
        child: &mut W,
        ctx: &mut druid::UpdateCtx,
        old_data: &T,
        data: &T,
        env: &druid::Env,
    ) {
        child.update(ctx, old_data, data, env)
    }
}

pub fn main() {
    let image_folder_path = Path::new(&std::env::current_dir().unwrap())
        .to_path_buf()
        .join("src/images/1/");

    let mut images = HashMap::new();

    for image_path in std::fs::read_dir(image_folder_path).unwrap() {
        let image_path = image_path.unwrap();
        let image = image::open(image_path.path()).unwrap();

        images.insert(image_path.file_name().to_str().unwrap().to_owned(), image);
    }

    let data = AppState::new();
    let main_window = WindowDesc::new(move || ui_builder(&images));
    AppLauncher::with_window(main_window)
        .use_simple_logger()
        .launch(data)
        .expect("launch failed");
}

fn ui_builder(images: &HashMap<String, DynamicImage>) -> impl Widget<AppState> {
    let mut col = Flex::column();
    let mut image_row = Flex::row();

    let image_list = images.iter().map(|s| s.0).collect::<Vec<_>>();

    for chunk in image_list.chunks(2) {
        let label_1_str = chunk[0].to_string();
        let label_2_str = chunk[1].to_string();

        let label_1 = Button::new(label_1_str.clone())
            .on_click(move |_ctx, data: &mut AppState, _env| {
                data.selected_image = label_1_str.clone().into()
            })
            .fix_width(250.0);

        let label_2 = Button::new(label_2_str.clone())
            .on_click(move |_ctx, data: &mut AppState, _env| {
                data.selected_image = label_2_str.clone().into()
            })
            .fix_width(250.0);

        let mut label_row = Flex::row()
            .with_child(label_1)
            .with_default_spacer()
            .with_child(label_2);

        label_row.set_main_axis_alignment(MainAxisAlignment::SpaceAround);
        col.add_flex_child(label_row, 1.0);
    }

    let selected_image = images.get("").unwrap().clone();
    let (width, heigth) = get_dimensions(&selected_image);

    let img = selected_image.to_druid_image().fix_width(width as f64);

    let flip_h = selected_image.brighten(10).to_druid_image();

    image_row.add_flex_child(img, 1.0);
    image_row.add_default_spacer();
    image_row.add_flex_child(flip_h, 1.0);

    col.add_child(image_row);

    // let img = Image::new(png_data.clone())
    //     .border(Color::WHITE, 1.0)
    //     .fix_width(100.0)
    //     .center();

    // let otherimage = Image::new(png_data)
    //     .fill_mode(FillStrat::FitWidth)
    //     .border(Color::WHITE, 1.0);
    // col.add_flex_child(otherimage, 1.0);
    col
}

fn make_todo_item() -> impl Widget<TodoItem> {
    // A label that generates its text based on the data:
    let title = Label::dynamic(|text: &String, _| text.to_string()).lens(TodoItem::title);
    let completed = Checkbox::new("Completed:").lens(TodoItem::completed);
    let urgent = Checkbox::new("Urgent:").lens(TodoItem::urgent);

    Flex::column()
        // label on top
        .with_child(title)
        // two checkboxes below
        .with_child(Flex::row().with_child(completed).with_child(urgent))
}

pub fn get_dimensions(img: &DynamicImage) -> (u32, u32) {
    let (ax, ay, bx, by) = img.bounds();
    let width = bx - ax;
    let height = by - ay;

    (width, height)
}
